# Lab4 实验报告

## 编程作业

### 硬链接

为了实现硬链接，首先在 `DiskInode` 中添加一个 `refcnt` 字段，用于记录硬链接数。这里没有使用原子操作，是因为每次操作 `Inode` 前都会加锁，所以不会出现竞争条件。

链接时，首先找到源文件的 `Inode` 并且将其 `refcnt` 加一，然后创建一个新的 `DirEntry`，将其 `Inode` 指向源文件的 `Inode`，并且写入 `ROOT_INODE` 的数据块末尾，将其记录下来。

删除链接时，首先找到文件的 `Inode` 并且将其 `refcnt` 减一，如果 `refcnt` 为零，则需要清空并回收对应的数据块，操作和 `clear` 类似。最后，需要将原来的 `DirEntry` 设置为空，这里没有直接删除 `DirEntry`，是因为这样实现起来比较困难。

使用 `fstat` 查询时，首先通过文件操作符表找到对应的 `File`，然后通过 `File` 获取对应的信息，这里我选择给 `File` 特型 (Trait) 添加一个 `stat` 方法。

## 问答作业

## 在我们的easy-fs中，root inode起着什么作用？如果root inode中的内容损坏了，会发生什么？

root inode 是根目录的 inode，我们通过它索引其他文件和目录。如果 root inode 中的内容损坏了，那么我们将无法找到其他文件和目录，整个文件系统将无法使用。

## 举出使用 pipe 的一个实际应用的例子。

1. 统计文本行数 `cat file.txt | wc -l`。
2. 检查目录下是否有某个文件 `ls | grep file.txt`。
3. curl 脚本并执行 `curl http://example.com/script.sh | bash`。

等等。

## 如果需要在多个进程间互相通信，则需要为每一对进程建立一个管道，非常繁琐，请设计一个更易用的多进程通信机制。

可以通过消息队列来实现，通过在内核中维护多个消息队列，允许不同进程向消息队列中发送消息，也可以从消息队列中接收消息。
以 Linux 为例，可以通过 `msgget` 创建一个消息队列，通过 `msgsnd` 向消息队列中发送消息，通过 `msgrcv` 从消息队列中接收消息。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了以下资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

<https://www.bilibili.com/video/BV1nt4y1V7MS>：参考了其中对硬链接原理的讲解。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

## 建议

事实上 Lab 4 中的测评代码并不严谨，可以通过错误的实现在通过测试，例如将链接信息记录到内核的内存中。可以将文件系统的镜像持久化到测评机的文件系统中，然后多次启动关闭 QEMU 进行测试，如在第一次运行时链接一个文件，并在第二次运行时检查链接是否生效。