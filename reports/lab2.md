# Lab 2 实验报告

## 编程作业

### 重写 sys_get_time 和 sys_task_info

引入虚拟内存后 `sys_get_time` 和 `sys_task_info` 不工作的原因是，用户传入的参数是用户的虚拟内存地址，而内核需要通过物理内存访问该地址。因此，需要在内核中将用户的虚拟地址转换为内核的物理地址。

具体实现方法为，将虚拟地址的页面转换为物理地址的页面，然后将偏移量 (offset) 加到物理地址上。参考 `translated_byte_buffer` 实现了 `translated_time_val`。

将该函数改为泛型实现可以转换任意类型的指针，而在后续的 `ch5` 中有一个 `translated_refmut` 函数实现了此功能，所以我直接复制了这个函数的代码。

`sys_task_info` 的实现相比 `ch3` 在代码风格上做了一点小改进，使结构更清晰。

### mmap 和 munmap 匿名映射

观察 `prot` 参数的定义，发现将其左移 1 位并或上 U 位 (1 << 4) 即可得到对应的 MapPermission。

在此之前，`PageTable` 中的 `map` 会断言  `PageTableEntry` 的合法性 (V 位) 是否符合预期，但是在 `mmap` 和 `munmap` 中，任务 (Task) 可能传入非法参数，而内核不能在这种情况下 panic，所以我们需要修改这两个函数的签名，使其返回 `bool` 表示是否成功。

与上面的原因相同，`MapArea` 中的 `map_one`, `unmap_one`, `map`, 和 `unmap` 函数也需要修改签名。为了实现在用户 `mmap` 失败后，内存映射不会发生变化，因此在 `MapArea` 中的 `map` 函数中，如果遇到错误，会调用 `unmap` 函数将已经映射的内存释放。

随后，在 `MemorySet` 中实现了 `mmap` 和 `munmap` 函数，在任务的 `MemorySet` 中管理内存的映射。

然后在 `TaskControlBlock` 中调用 `MemorySet` 的 `mmap` 和 `munmap` 函数，实现了任务的 `mmap` 和 `munmap`。在这个过程中，检查了各个参数的合法性。

最后通过 `TaskManager` 将当前任务的 `mmap` 和 `munmap` 暴露给 `syscall` 的 `sys_mmap` 和 `sys_munmap` 使用。

## 问答作业

### 1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？

A: [63:54] 10 位为保留项，[53:10] 44 位为物理页项目，[9:8] 为 `RSW` 留给 S 态的应用程序，[7:0] 依次为 `D` (脏位)、`A` (访问位)、`G` (全局位)、`U` (用户位)、`X` (执行位)、`W` (写位)、`R` (读位)和 `V` (有效位)。

其中 `D` 为脏位，表示该页是否被写入过，`A` 为访问位，表示该页是否被访问过，`G` 为全局位，表示该页是否是全局页，`U` 为用户位，表示该页是否是用户页，`X` 为执行位，表示该页是否可执行，`W` 为写位，表示该页是否可写，`R` 为读位，表示该页是否可读，`V` 为有效位，表示该页是否有效。

### 2. 缺页

缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。

- 请问哪些异常可能是缺页导致的？
  A: 当页表项无效、权限不足、页面不在内存中时，会触发缺页异常。
- 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。
  A: 
  + `scause` 的最高位为 `0` 表示异常，故该寄存器值可能为 `6` (StoreFault)，`11` (StorePageFault)，`4` (LoadFault)，`10` (LoadPageFault)。
  + `stval` 为触发异常的指令地址。
  + `satp` 为页表基址。
  + `spec` 为触发异常的指令的地址。

缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

- 这样做有哪些好处？
  A： 不需要一次性将所有的代码加载到内存中，节省了内存空间，提高了内存的利用率。

其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。

- 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

A: 一级页表和二级页表较少可以忽略不计。以 4K 页面大小为例，每个页面需要 8 字节，故内存大小和三级页表比值为 4K/8B = 512。10G 内存的页表项需要约 10G/512 = 20M 内存。 

- 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

A: 在分配内存时，并不实际上分配物理内存，而是将虚拟地址和物理地址的映射关系保存在页表中。当访问到某个虚拟地址时，如果对应的物理地址没有分配，则触发缺页异常，此时再分配物理内存，并更新页表。

缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

- 此时页面失效如何表现在页表项(PTE)上？

页表项中的 `V` 位为 0，表示该页表项无效。当访问到该页表项时，会触发缺页异常，此时再将页面从磁盘加载到内存中，并更新页表，使 `V` 位为 1。

### 3.双页表与单页表

为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )

- 在单页表情况下，如何更换页表？

A: 单页表下，在任务切换时，需要将当前任务的页表切换为下一个任务的页表。在 RISC-V 中，页表基址保存在 `satp` 寄存器中，因此只需要将 `satp` 寄存器设置为下一个任务的页表基址即可。

- 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）
  
A: 在页表项中设置 `U` 位为 0，表示该页不是用户页，用户态无法访问。

- 单页表有何优势？（回答合理即可）

A: 单页表不需要切换页表，也不需要跳板页，减少了切换页表的开销。

- 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

A: 双页表下，当出现特权级别切换时（如陷入），需要更换页表，任务切换时也需要切换页表。在单页表操作系统中，可以选择在任务切换时更换页表。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了以下资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

<https://github.com/LearningOS/rCore-Tutorial-Code-2024A/blob/ch5/os/src/mm/page_table.rs>：复制了 `translated_refmut` 函数和 `MapArea` 中的 `translate_va` 函数的实现代码。
<https://nankai.gitbook.io/ucore-os-on-risc-v64/lab2/di-zhi-yu-ye-biao>：参考了其中对于页表项（PTE）中对于 `RSW` 的解释。


3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
